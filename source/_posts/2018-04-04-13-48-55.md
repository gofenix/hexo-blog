---
title: Go语言体会
date: 2018-04-04 13:48:57
tags: 
    - go
---

最近公司要统一技术栈，在kotlin和go之间选。我心里是比较倾向go的，主要有如下几点体会。

- 语言简单，上手快。
- gorotuine
- 易发布
- 垃圾回收
- 约定大于配置

我最早听说协程，是在大三找实习的时候，那个时候面试会问线程和进程的关系，问的深一些就是协程和线程的区别。游戏公司基本都用lua，看了lua的资料后，对协程有了一些自己的了解，随后就是在做Unity相关的开发，在unity中使用了很多的协程，但是在unity中使用的协程好像跟主流的不太一样，在看了go之后，豁然开朗。

goroutine使用的内存比线程更少，go在运行的时候会自动在配置的一组逻辑处理器上调度执行。比如：

```go
func log(msg string){
    ...
}

go log("")
```

使用关键字go，即可让log函数在一个goroutine里执行了。

并发最难的部分是要确保其他并发运行的进程、线程或者goroutine不会以外的修改数据。go使用了Channel的方式来解决这个问题。对于通道模式，保证同一时刻只会有一个goroutine修改数据。

说起go的语言简单，其实主要是他的类型比较简单。go使用的是组合模式，只需要将一个类型嵌入到另外一个类型就可以复用所有的功能。而且go还具有独特的接口实现机制，允许用户对行为进行建模，在go中不需要声明某个类型实现了某个接口，编译器会自动判断一个实例是使用什么接口。

对于java来说，所有的设计都是围绕着接口展开，于是在设计模式中，就是面向接口编程：

```go
interface User{
    void login();
    void logout();
}
```

在java中，继承的类必须显式声明继承了此接口。而在go中接口只是描述一个动作，如果说是实现这个接口，只需要让某个实例实现了这个接口中的所有方法就行了。

```go
type Reader interface{
    Read(p []byte))(n int, err error)
}
```

这其实和传统的oop语言的接口有着本质的区别，go中的接口一般只定义一个单一的动作，实际使用的过程中，这更有利于使用组合来复用代码。

约定大于配置这点，go在这方面上做的感觉有点儿吹毛求疵了，但是这样也使得程序可读性更强，没有很多垃圾代码。比如go的文件结构必须是src pkg 和bin 三个包，而且go也不允许你声明一个变量却不使用，导入了一个包却不使用，而且程序的代码也有约定，init方法比main方法更早执行。



